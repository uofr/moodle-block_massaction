{"version":3,"file":"checkboxmanager.min.js","sources":["../src/checkboxmanager.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Checkbox manager amd module: Adds checkboxes to the activities for selecting and\n * generates a data structure of the activities and checkboxes.\n *\n * @module     block_massaction/checkboxmanager\n * @copyright  2022 ISB Bayern\n * @author     Philipp Memmel\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport {exception as displayException} from 'core/notification';\nimport {cssIds, constants, usedMoodleCssClasses} from './massactionblock';\nimport {getCurrentCourseEditor} from 'core_courseformat/courseeditor';\nimport events from 'core_course/events';\n\nlet localStateUpdating = false;\nlet sectionsChanged = false;\nlet sections = [];\nlet moduleNames = [];\n\n/* A registry of checkbox IDs, of the format:\n *  'section_number' => [{'moduleId'   : <module-ID>,\n *                       'boxId'       : <checkbox_id>}]\n */\nconst sectionBoxes = {};\n\n/**\n * The checkbox manager takes a given 'sections' data structure object and inserts a checkbox for each of the given\n * course modules in this data object into the DOM.\n * The checkbox manager returns another data object containing the ids of the added checkboxes.\n */\nexport const initCheckboxManager = () => {\n    const courseEditor = getCurrentCourseEditor();\n\n    const eventsToListen = {\n        SECTION_UPDATED: 'section:updated',\n        CHANGE_FINISHED: 'transaction:end'\n    };\n\n    courseEditor.stateManager.target.addEventListener(events.stateChanged, (event) => {\n        if (event.detail.action === eventsToListen.SECTION_UPDATED) {\n            // Listen to section updated events. We do not want to immediately react to the event, but wait for\n            // everything to finish updating.\n            sectionsChanged = true;\n        }\n        if (event.detail.action === eventsToListen.CHANGE_FINISHED) {\n            // Before every change to the state there is a transaction:start event. After the change is being commited,\n            // we receive an transaction:end event. That is the point we want to react to changes of the state.\n            rebuildLocalState();\n        }\n    });\n    // Trigger rendering of sections dropdowns a first time.\n    sectionsChanged = true;\n    // Get initial state.\n    rebuildLocalState();\n};\n\n/**\n * This method rebuilds the local state maintained in this module based on the course editor state.\n *\n * It will be called whenever a change to the courseeditor state is being detected.\n */\nconst rebuildLocalState = () => {\n    if (localStateUpdating) {\n        return;\n    }\n    localStateUpdating = true;\n\n    // First we rebuild our data structures depending on the course editor state.\n    for (const prop of Object.getOwnPropertyNames(sectionBoxes)) {\n        delete sectionBoxes[prop];\n    }\n\n    const courseEditor = getCurrentCourseEditor();\n    const state = courseEditor.stateManager.state;\n    const exporter = courseEditor.getExporter();\n\n    // Get all modules, sections and subsections in display order.\n    const courseItems = exporter.allItemsArray(state);\n\n    // Build sections array.\n    sections = [];\n    courseItems.forEach(item => {\n        if (item.type === 'section') {\n            // Get section info.\n            let sectioninfo = {...state.section.get(item.id)};\n            // Rename subsections for display purposes.\n            sectioninfo.title = getTitleOfSection(sectioninfo);\n            sections.push(sectioninfo);\n        }\n    });\n\n    // Get all module names and parameters.\n    moduleNames = [...courseEditor.stateManager.state.cm.values()];\n\n    // Now we use the new information to rebuild dropdowns and re-apply checkboxes.\n    const sectionsUnfiltered = sections;\n    sections = filterVisibleSections(sections);\n    updateSelectionAndMoveToDropdowns(sections, sectionsUnfiltered);\n    addCheckboxesToDataStructure();\n    localStateUpdating = false;\n};\n\n/**\n * Returns the title of a given section.\n * If the section is a subsection, a prefix with a dash is added.\n *\n * @param {Object} section the section object from the course editor\n * @returns {string} title of the section object corrected for subsections\n */\nexport const getTitleOfSection = (section) => {\n    let title = section.title;\n    if (section.component === 'mod_subsection') {\n        title = ' - ' + title;\n    }\n    return title;\n};\n\n/**\n * Returns the currently selected module ids.\n *\n * @returns {[]} Array of module ids currently being selected\n */\nexport const getSelectedModIds = () => {\n    const moduleIds = [];\n    for (let sectionNumber in sectionBoxes) {\n        for (let i = 0; i < sectionBoxes[sectionNumber].length; i++) {\n            const checkbox = document.getElementById(sectionBoxes[sectionNumber][i].boxId);\n            if (checkbox.checked) {\n                moduleIds.push(sectionBoxes[sectionNumber][i].moduleId);\n            }\n        }\n    }\n\n    return moduleIds;\n};\n\n/**\n * Select all module checkboxes in section(s).\n *\n * @param {boolean} value the checked value to set the checkboxes to\n * @param {string} sectionNumber the section number of the section which all modules should be checked/unchecked. Use \"all\" to\n *  select/deselect modules in all sections.\n */\nexport const setSectionSelection = (value, sectionNumber) => {\n    const boxIds = [];\n    if (typeof sectionNumber !== 'undefined' && sectionNumber === constants.SECTION_SELECT_DESCRIPTION_VALUE) {\n        // Description placeholder has been selected, do nothing.\n        return;\n    } else if (typeof sectionNumber !== 'undefined' && sectionNumber === constants.SECTION_NUMBER_ALL_PLACEHOLDER) {\n        // See if we are toggling all sections.\n        for (const sectionId in sectionBoxes) {\n            for (let j = 0; j < sectionBoxes[sectionId].length; j++) {\n                boxIds.push(sectionBoxes[sectionId][j].boxId);\n            }\n        }\n    } else {\n        // We select all boxes of the given section.\n        sectionBoxes[sectionNumber].forEach(box => boxIds.push(box.boxId));\n    }\n\n    // Un/check the boxes.\n    for (let i = 0; i < boxIds.length; i++) {\n        document.getElementById(boxIds[i]).checked = value;\n    }\n    // Reset dropdown to standard placeholder so we trigger a change event when selecting a section, then deselecting\n    // everything and again select the same section.\n    document.getElementById(cssIds.SECTION_SELECT).value = constants.SECTION_SELECT_DESCRIPTION_VALUE;\n};\n\n/**\n * Scan all available checkboxes and add them to the data structure.\n */\nconst addCheckboxesToDataStructure = () => {\n    sections.forEach(section => {\n        sectionBoxes[section.number] = [];\n        const moduleIds = section.cmlist;\n\n        if (moduleIds && moduleIds.length > 0 && moduleIds[0] !== '') {\n            const moduleNamesFiltered = moduleNames.filter(modinfo => moduleIds.includes(modinfo.id.toString()));\n            moduleNamesFiltered.forEach(modinfo => {\n                if (modinfo.module !== 'subsection') {\n                    // Checkbox should already be created by moodle massactions. Just add it to our data structure.\n                    const boxId = usedMoodleCssClasses.BOX_ID_PREFIX + modinfo.id.toString();\n                    sectionBoxes[section.number].push({\n                        'moduleId': modinfo.id.toString(),\n                        'boxId': boxId,\n                    });\n                }\n            });\n        }\n    });\n};\n\n/**\n * Filter the sections data object depending on the visibility of the course modules contained in\n * the data object. This is necessary, because some course formats only show specific section(s)\n * in editing mode.\n *\n * @param {[]} sections the sections data object\n * @returns {[]} the filtered sections object\n */\nconst filterVisibleSections = (sections) => {\n    // Filter all sections with modules which no checkboxes have been created for.\n    // This case should only occur in course formats where some sections are hidden.\n    return sections.filter(section => section.cmlist.length !== 0)\n        .filter(section => section.cmlist\n            .every(moduleid => document.getElementById(usedMoodleCssClasses.MODULE_ID_PREFIX + moduleid) !== null));\n};\n\n/**\n * Update the selection, moveto and duplicateto dropdowns of the massaction block according to the\n * previously filtered sections.\n *\n * This method also has to be called whenever there is a module change event (moving around, adding file by Drag&Drop etc.).\n *\n * @param {[]} sections the sections object filtered before by {@link filterVisibleSections}\n * @param {[]} sectionsUnfiltered the same data object as 'sections', but still containing all sections\n */\nconst updateSelectionAndMoveToDropdowns = (sections, sectionsUnfiltered) => {\n    if (sectionsChanged) {\n        Templates.renderForPromise('block_massaction/section_select', {'sections': sectionsUnfiltered})\n            .then(({html, js}) => {\n                Templates.replaceNode('#' + cssIds.SECTION_SELECT, html, js);\n                disableInvisibleAndEmptySections(sections);\n                // Re-register event listener.\n                document.getElementById(cssIds.SECTION_SELECT).addEventListener('change',\n                    (event) => setSectionSelection(true, event.target.value), false);\n                return true;\n            })\n            .catch(ex => displayException(ex));\n\n        Templates.renderForPromise('block_massaction/moveto_select', {'sections': sectionsUnfiltered})\n            .then(({html, js}) => {\n                Templates.replaceNode('#' + cssIds.MOVETO_SELECT, html, js);\n                disableUnavailableSections(cssIds.MOVETO_SELECT);\n                return true;\n            })\n            .catch(ex => displayException(ex));\n\n        Templates.renderForPromise('block_massaction/duplicateto_select', {'sections': sectionsUnfiltered})\n            .then(({html, js}) => {\n                Templates.replaceNode('#' + cssIds.DUPLICATETO_SELECT, html, js);\n                disableUnavailableSections(cssIds.DUPLICATETO_SELECT);\n                return true;\n            })\n            .catch(ex => displayException(ex));\n    } else {\n        // If there has not been an event about a section change we do not have to rebuild the sections dropdowns.\n        // However, there is a chance a section is being emptied or not empty anymore due to drag&dropping of modules.\n        // So we have to recalculate if we have to enable/disable the sections.\n        disableInvisibleAndEmptySections(sections);\n    }\n    // Reset the flag.\n    sectionsChanged = false;\n};\n\n/**\n * Sets the disabled/enabled status of sections in the section select dropdown:\n * Enabled if section is visible and contains modules.\n * Disabled if section is not visible or doesn't contain any modules.\n *\n * @param {[]} sections the section data structure\n */\nconst disableInvisibleAndEmptySections = (sections) => {\n    Array.prototype.forEach.call(document.getElementById(cssIds.SECTION_SELECT).options, option => {\n        // Disable every element which doesn't have a visible section, except the placeholder ('description').\n        if (option.value !== constants.SECTION_SELECT_DESCRIPTION_VALUE\n                && !sections.some(section => parseInt(option.value) === section.number)) {\n            option.disabled = true;\n        } else {\n            option.disabled = false;\n        }\n    });\n};\n\n/**\n * Sets the disabled/enabled status of sections in the section select dropdown:\n * Disabled if the section is not available due to some restrictions in block_massaction itself (provided by hooks).\n *\n * @param {string} elementId elementId to apply the restriction\n */\nconst disableUnavailableSections = (elementId) => {\n    if (document.getElementById(elementId) !== null) {\n        const sectionsAvailableInfo = document.querySelector(cssIds.SECTION_FILTER_DATA).dataset.availabletargetsections;\n        const sectionsAvailable = Array.prototype.map.call(sectionsAvailableInfo.split(','), (sectionnum) => parseInt(sectionnum));\n        Array.prototype.forEach.call(document.getElementById(elementId).options, option => {\n            // Disable every element which is not in the sectionsAvailable list.\n            if (sectionsAvailable.includes(parseInt(option.value))) {\n                option.disabled = false;\n            } else {\n                option.disabled = true;\n            }\n        });\n    }\n};\n"],"names":["localStateUpdating","sectionsChanged","sections","moduleNames","sectionBoxes","courseEditor","eventsToListen","stateManager","target","addEventListener","events","stateChanged","event","detail","action","rebuildLocalState","prop","Object","getOwnPropertyNames","state","courseItems","getExporter","allItemsArray","forEach","item","type","sectioninfo","section","get","id","title","getTitleOfSection","push","cm","values","sectionsUnfiltered","filterVisibleSections","updateSelectionAndMoveToDropdowns","addCheckboxesToDataStructure","component","moduleIds","sectionNumber","i","length","document","getElementById","boxId","checked","moduleId","setSectionSelection","value","boxIds","constants","SECTION_SELECT_DESCRIPTION_VALUE","SECTION_NUMBER_ALL_PLACEHOLDER","sectionId","j","box","cssIds","SECTION_SELECT","number","cmlist","filter","modinfo","includes","toString","module","usedMoodleCssClasses","BOX_ID_PREFIX","every","moduleid","MODULE_ID_PREFIX","renderForPromise","then","_ref","html","js","replaceNode","disableInvisibleAndEmptySections","catch","ex","_ref2","MOVETO_SELECT","disableUnavailableSections","_ref3","DUPLICATETO_SELECT","Array","prototype","call","options","option","some","parseInt","disabled","elementId","sectionsAvailableInfo","querySelector","SECTION_FILTER_DATA","dataset","availabletargetsections","sectionsAvailable","map","split","sectionnum"],"mappings":"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"}